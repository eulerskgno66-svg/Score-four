<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>立体四目 (4×4×4) vs 最強AI</title>
<style>
  :root{
    --bg:#0b1020; --panel:#121a33; --text:#e8eeff; --muted:#94a3c7;
    --p1:#ffd166; --p2:#66d9ef; --grid:#243055; --accent:#7c5cff;
  }
  body{ margin:0; background:linear-gradient(180deg,var(--bg),#070a14); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  .wrap{ max-width:1050px; margin:0 auto; padding:16px; display:grid; gap:12px; grid-template-columns: 1fr 320px;}
  @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }
  .card{ background:rgba(18,26,51,.85); border:1px solid rgba(124,92,255,.25); border-radius:14px; overflow:hidden; box-shadow:0 12px 30px rgba(0,0,0,.25); }
  .topbar{ padding:12px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px; background:rgba(255,255,255,.03); border-bottom:1px solid rgba(255,255,255,.06); }
  .title{ font-weight:800; letter-spacing:.5px; }
  .sub{ color:var(--muted); font-size:12px; }
  .canvasWrap{ position:relative; }
  canvas{ width:100%; height:auto; display:block; background: radial-gradient(1200px 600px at 30% 20%, rgba(124,92,255,.10), transparent 55%),
                                          radial-gradient(1000px 700px at 70% 60%, rgba(102,217,239,.08), transparent 55%); }
  .side{ padding:12px 14px; display:grid; gap:12px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select{
    background:#0f1730; color:var(--text);
    border:1px solid rgba(255,255,255,.14); border-radius:10px;
    padding:10px 12px; font-weight:650; cursor:pointer;
  }
  button:hover{ border-color: rgba(124,92,255,.6); }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .pill{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08); font-size:12px; color:var(--muted); }
  .status{ padding:10px 12px; background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08); border-radius:12px; }
  .kvs{ display:grid; gap:6px; }
  .kv{ display:flex; justify-content:space-between; gap:10px; font-size:13px; }
  .kv b{ color:var(--text); }
  .hint{ font-size:12px; color:var(--muted); line-height:1.45; }
  .legend{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
  .p1{ background:var(--p1); box-shadow:0 0 0 2px rgba(255,209,102,.25); }
  .p2{ background:var(--p2); box-shadow:0 0 0 2px rgba(102,217,239,.25); }
  .footer{ padding:10px 14px; border-top:1px solid rgba(255,255,255,.06); color:var(--muted); font-size:12px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div>
        <div class="title">立体四目 4×4×4（重力あり）</div>
        <div class="sub">柱（16本）をタップして落とす / 直線に4つで勝ち（3D斜め全部含む）</div>
      </div>
      <div class="pill" id="turnPill">Turn: -</div>
    </div>
    <div class="canvasWrap">
      <canvas id="cv" width="980" height="720"></canvas>
    </div>
    <div class="footer">操作：柱をタップ → 駒が落ちる。勝敗後は「リセット」か「1手戻す」。</div>
  </div>

  <div class="card">
    <div class="topbar">
      <div class="title">設定</div>
      <div class="sub">AI：反復深化 + αβ枝刈り + 置換表（強め）</div>
    </div>
    <div class="side">
      <div class="legend">
        <span class="dot p1"></span><span class="pill">あなた（先手）</span>
        <span class="dot p2"></span><span class="pill">AI（後手）</span>
      </div>

      <div class="row">
        <button id="resetBtn">リセット</button>
        <button id="undoBtn">1手戻す</button>
      </div>

      <div class="row">
        <label class="pill">AI強さ</label>
        <select id="levelSel">
          <option value="4">強い（深さ4）</option>
          <option value="5">かなり強い（深さ5）</option>
          <option value="6" selected>最強寄り（深さ6）</option>
          <option value="7">超強い（深さ7 / 重め）</option>
        </select>
      </div>

      <div class="row">
        <label class="pill">AI思考</label>
        <select id="thinkSel">
          <option value="350" selected>速い</option>
          <option value="650">普通</option>
          <option value="1100">粘る</option>
        </select>
      </div>

      <div class="status">
        <div class="kvs">
          <div class="kv"><span>状態</span><b id="statusText">準備OK</b></div>
          <div class="kv"><span>AI探索ノード</span><b id="nodeText">0</b></div>
          <div class="kv"><span>AI最終深さ</span><b id="depthText">-</b></div>
          <div class="kv"><span>候補（上位）</span><b id="pvText">-</b></div>
        </div>
      </div>

      <div class="hint">
        ・「最強寄り」は <b>深さ6 + 反復深化</b>。<br/>
        ・勝ち/負けが近い局面ほどかなり強い。<br/>
        ・さらに強くしたい場合は WebWorker 化や評価関数の増強もできる（言って）。<br/>
      </div>
    </div>
  </div>
</div>

<script>
/** 立体四目 4x4x4 (gravity) **/
const N=4;
const EMPTY=0, HUMAN=1, AI=2;

// board[z][y][x]  (z:高さ 0..3 下->上)
function makeBoard(){
  const b=[];
  for(let z=0; z<N; z++){
    const layer=[];
    for(let y=0; y<N; y++){
      layer.push(new Array(N).fill(0));
    }
    b.push(layer);
  }
  return b;
}

let board = makeBoard();
let history = []; // {x,y,z,player}
let gameOver=false;
let current = HUMAN;

// UI
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d');
const turnPill=document.getElementById('turnPill');
const statusText=document.getElementById('statusText');
const nodeText=document.getElementById('nodeText');
const depthText=document.getElementById('depthText');
const pvText=document.getElementById('pvText');
const resetBtn=document.getElementById('resetBtn');
const undoBtn=document.getElementById('undoBtn');
const levelSel=document.getElementById('levelSel');
const thinkSel=document.getElementById('thinkSel');

resetBtn.onclick=()=>resetGame();
undoBtn.onclick=()=>undoMove();

function resetGame(){
  board=makeBoard();
  history=[];
  gameOver=false;
  current=HUMAN;
  setStatus("準備OK");
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";
  draw();
  updateTurnPill();
}
function undoMove(){
  if(history.length===0) return;
  if(gameOver){ gameOver=false; }
  // undo last move (maybe AI)
  const m1=history.pop();
  board[m1.z][m1.y][m1.x]=EMPTY;
  current=m1.player;
  // if last was AI, also undo human so turn returns to human nicely
  if(current===AI && history.length>0){
    const m2=history.pop();
    board[m2.z][m2.y][m2.x]=EMPTY;
    current=m2.player;
  }
  setStatus("1手戻しました");
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";
  draw();
  updateTurnPill();
}

function setStatus(t){ statusText.textContent=t; }
function updateTurnPill(){
  if(gameOver){ turnPill.textContent="Game Over"; return; }
  turnPill.textContent = "Turn: " + (current===HUMAN?"あなた":"AI");
}

// gravity drop: returns z or -1 if full
function dropZ(b,x,y){
  for(let z=0; z<N; z++){
    if(b[z][y][x]===EMPTY) return z;
  }
  return -1;
}
function playMove(b,x,y,player){
  const z=dropZ(b,x,y);
  if(z<0) return null;
  b[z][y][x]=player;
  return {x,y,z,player};
}
function undoOnBoard(b,move){
  b[move.z][move.y][move.x]=EMPTY;
}

function inBounds(x,y,z){ return x>=0&&x<N&&y>=0&&y<N&&z>=0&&z<N; }

// all 3D direction vectors (unique up to sign)
const DIRS = [];
(function(){
  const seen=new Set();
  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      for(let dz=-1; dz<=1; dz++){
        if(dx===0&&dy===0&&dz===0) continue;
        // normalize sign: make first nonzero positive
        let ndx=dx, ndy=dy, ndz=dz;
        if(ndx!==0){ if(ndx<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        else if(ndy!==0){ if(ndy<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        else { if(ndz<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        const key=`${ndx},${ndy},${ndz}`;
        if(!seen.has(key)){
          seen.add(key);
          DIRS.push([ndx,ndy,ndz]);
        }
      }
    }
  }
})();

// precompute all 4-in-a-row lines as arrays of 4 cells
const LINES = [];
(function(){
  for(let x=0;x<N;x++)for(let y=0;y<N;y++)for(let z=0;z<N;z++){
    for(const [dx,dy,dz] of DIRS){
      const cells=[];
      for(let k=0;k<4;k++){
        const xx=x+dx*k, yy=y+dy*k, zz=z+dz*k;
        if(!inBounds(xx,yy,zz)){ cells.length=0; break; }
        cells.push([xx,yy,zz]);
      }
      if(cells.length===4){
        // avoid duplicates by canonical start: previous cell out of bounds
        const px=x-dx, py=y-dy, pz=z-dz;
        if(!inBounds(px,py,pz)){
          LINES.push(cells);
        }
      }
    }
  }
})();

function checkWinner(b){
  for(const line of LINES){
    const a=b[line[0][2]][line[0][1]][line[0][0]];
    if(a===EMPTY) continue;
    let ok=true;
    for(let i=1;i<4;i++){
      const [x,y,z]=line[i];
      if(b[z][y][x]!==a){ ok=false; break; }
    }
    if(ok) return a;
  }
  return 0;
}
function isFull(b){
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(dropZ(b,x,y)>=0) return false;
  }
  return true;
}

function legalMoves(b){
  const moves=[];
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(dropZ(b,x,y)>=0) moves.push({x,y});
  }
  return moves;
}

/** --- AI (negamax + alpha-beta + iterative deepening + TT) --- **/

// Zobrist hashing
const Z = (function(){
  // Z[player][z][y][x]  player:1..2
  const arr=[null,[],[]];
  let seed=0x9e3779b9;
  function rnd32(){
    // xorshift
    seed ^= (seed<<13)>>>0;
    seed ^= (seed>>>17)>>>0;
    seed ^= (seed<<5)>>>0;
    return seed>>>0;
  }
  for(let p=1;p<=2;p++){
    arr[p]=[];
    for(let z=0;z<N;z++){
      arr[p][z]=[];
      for(let y=0;y<N;y++){
        arr[p][z][y]=[];
        for(let x=0;x<N;x++){
          const hi=rnd32(), lo=rnd32();
          arr[p][z][y][x]=BigInt(hi)<<32n | BigInt(lo);
        }
      }
    }
  }
  const turnKey = BigInt(rnd32())<<32n | BigInt(rnd32());
  return {arr, turnKey};
})();

function hashBoard(b, turnPlayer){
  let h=0n;
  for(let z=0;z<N;z++)for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    const v=b[z][y][x];
    if(v!==EMPTY) h ^= Z.arr[v][z][y][x];
  }
  if(turnPlayer===AI) h ^= Z.turnKey;
  return h;
}

// evaluation: line-based (counts in each 4-line)
function evalBoard(b){
  // terminal
  const w=checkWinner(b);
  if(w===AI) return 1000000;
  if(w===HUMAN) return -1000000;
  let score=0;

  // Favor center-ish columns (x,y near 1.5)
  for(let z=0;z<N;z++)for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    const v=b[z][y][x];
    if(v===EMPTY) continue;
    const cx = 1.5 - Math.abs(1.5-x);
    const cy = 1.5 - Math.abs(1.5-y);
    const cz = 1.5 - Math.abs(1.5-z);
    const wgt = 1 + (cx+cy+cz)*0.20;
    score += (v===AI? +wgt : -wgt);
  }

  // Line potentials
  for(const line of LINES){
    let a=0, h=0;
    for(const [x,y,z] of line){
      const v=b[z][y][x];
      if(v===AI) a++;
      else if(v===HUMAN) h++;
    }
    if(a>0 && h>0) continue; // blocked
    if(a===0 && h===0) continue;
    // weights for 1/2/3-in-line
    const W=[0, 12, 70, 550];
    if(a>0) score += W[a];
    else score -= W[h];
  }
  return Math.round(score);
}

// Transposition table
// entry: {depth, flag, value, bestMove:{x,y}}  flag:0 exact,1 lower,2 upper
const TT = new Map();

let aiNodes=0;
let stopAt=0;
let lastPV=[];

function orderMoves(b, moves){
  // try center first, then by immediate win/block, then heuristic quick eval
  const scored=[];
  for(const m of moves){
    let s=0;
    const cx = 1.5 - Math.abs(1.5-m.x);
    const cy = 1.5 - Math.abs(1.5-m.y);
    s += (cx+cy)*10;

    // immediate win?
    const mvA=playMove(b,m.x,m.y,AI);
    if(mvA){
      if(checkWinner(b)===AI) s += 100000;
      undoOnBoard(b,mvA);
    }
    // immediate block?
    const mvH=playMove(b,m.x,m.y,HUMAN);
    if(mvH){
      if(checkWinner(b)===HUMAN) s += 90000;
      undoOnBoard(b,mvH);
    }
    scored.push([s,m]);
  }
  scored.sort((a,b)=>b[0]-a[0]);
  return scored.map(x=>x[1]);
}

function negamax(b, depth, alpha, beta, turnPlayer){
  aiNodes++;
  if(performance.now()>stopAt) return {value: evalBoard(b), move:null, timeout:true};

  const h = hashBoard(b, turnPlayer);
  const tt = TT.get(h);
  if(tt && tt.depth>=depth){
    if(tt.flag===0) return {value: tt.value, move: tt.bestMove, timeout:false};
    if(tt.flag===1) alpha = Math.max(alpha, tt.value);
    else if(tt.flag===2) beta = Math.min(beta, tt.value);
    if(alpha>=beta) return {value: tt.value, move: tt.bestMove, timeout:false};
  }

  const w=checkWinner(b);
  if(w!==0) return {value: (w===AI? 1000000: -1000000) - (6-depth), move:null, timeout:false};
  if(depth===0 || isFull(b)) return {value: evalBoard(b), move:null, timeout:false};

  let bestMove=null;
  let bestVal=-Infinity;

  let moves=legalMoves(b);
  moves=orderMoves(b, moves);

  // Use TT move first if exists
  if(tt && tt.bestMove){
    const idx=moves.findIndex(m=>m.x===tt.bestMove.x && m.y===tt.bestMove.y);
    if(idx>0){
      const [m]=moves.splice(idx,1);
      moves.unshift(m);
    }
  }

  for(const m of moves){
    const mv=playMove(b,m.x,m.y,turnPlayer);
    if(!mv) continue;

    const res = negamax(b, depth-1, -beta, -alpha, (turnPlayer===AI?HUMAN:AI));
    undoOnBoard(b,mv);

    if(res.timeout) return {value: bestVal, move: bestMove, timeout:true};

    const val = -res.value;
    if(val>bestVal){
      bestVal=val;
      bestMove=m;
    }
    alpha=Math.max(alpha, bestVal);
    if(alpha>=beta) break; // cut
  }

  // store TT
  let flag=0;
  if(bestVal<=alpha) flag=2; // upper (note: alpha has moved; rough but ok)
  if(bestVal>=beta) flag=1;  // lower
  // Better: use original alpha0; keep simple but stable-ish:
  // We'll store exact if inside bounds heuristically
  TT.set(h, {depth, flag:0, value:bestVal, bestMove});

  return {value: bestVal, move: bestMove, timeout:false};
}

async function aiTurn(){
  if(gameOver) return;
  if(current!==AI) return;

  const maxDepth = parseInt(levelSel.value,10);
  const thinkMs = parseInt(thinkSel.value,10);

  setStatus("AI思考中…");
  disableInput(true);

  aiNodes=0;
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";
  lastPV=[];

  const start=performance.now();
  stopAt = start + thinkMs;

  let best=null;
  let bestVal=-Infinity;
  // iterative deepening
  for(let d=1; d<=maxDepth; d++){
    const alpha=-Infinity, beta=Infinity;
    const res = negamax(board, d, alpha, beta, AI);
    nodeText.textContent = String(aiNodes);
    if(res.timeout) break;
    if(res.move){
      best=res.move;
      bestVal=res.value;
      depthText.textContent=String(d);
      // PV-like: show best move column
      pvText.textContent=`(${best.x+1},${best.y+1}) val=${bestVal}`;
    }
    // yield to UI
    await new Promise(r=>setTimeout(r,0));
  }

  if(!best){
    // fallback: random legal
    const moves=legalMoves(board);
    best=moves[Math.floor(Math.random()*moves.length)];
  }

  const mv=playMove(board,best.x,best.y,AI);
  history.push(mv);
  draw();

  const w=checkWinner(board);
  if(w===AI){
    gameOver=true; setStatus("AIの勝ち"); updateTurnPill(); disableInput(false); return;
  }
  if(isFull(board)){
    gameOver=true; setStatus("引き分け"); updateTurnPill(); disableInput(false); return;
  }
  current=HUMAN;
  setStatus("あなたの手番");
  updateTurnPill();
  disableInput(false);
}

function disableInput(v){
  cv.style.pointerEvents = v? "none":"auto";
  resetBtn.disabled=v;
  undoBtn.disabled=v;
  levelSel.disabled=v;
  thinkSel.disabled=v;
}

/** --- Rendering (pseudo 3D) --- **/
const geom = {
  originX: 210, originY: 140,
  cell: 95,
  layerDrop: 28, // height spacing in screen
  skewX: 46,
  skewY: 26,
};

// Map column (x,y) to screen base point (top of column)
function colToScreen(x,y){
  const gx=geom.originX + x*geom.cell + y*geom.skewX;
  const gy=geom.originY + y*geom.cell*0.72 - x*geom.skewY;
  return {gx, gy};
}

// Precompute clickable areas for columns
let colHit=[];
function rebuildHit(){
  colHit=[];
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    const p=colToScreen(x,y);
    // diamond-ish area
    const r=40;
    colHit.push({
      x,y,
      poly:[
        {x:p.gx, y:p.gy-r},
        {x:p.gx+r, y:p.gy},
        {x:p.gx, y:p.gy+r},
        {x:p.gx-r, y:p.gy},
      ]
    });
  }
}

function pointInPoly(px,py,poly){
  let c=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>py)!==(yj>py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-9)+xi);
    if(intersect) c=!c;
  }
  return c;
}

function draw(){
  const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);

  // title-ish glow
  ctx.save();
  ctx.globalAlpha=0.22;
  ctx.fillStyle="#7c5cff";
  ctx.beginPath(); ctx.ellipse(W*0.28,H*0.10,220,70,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#66d9ef";
  ctx.beginPath(); ctx.ellipse(W*0.72,H*0.22,260,90,0,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // draw columns back-to-front for depth
  const order=[];
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    order.push({x,y, key:(x+y*1.8)});
  }
  order.sort((a,b)=>a.key-b.key);

  // base grid
  for(const c of order){
    drawColumn(c.x,c.y);
  }

  // pieces: draw by increasing z for same column, but columns already depth sorted helps
  for(const c of order){
    for(let z=N-1; z>=0; z--){
      const v=board[z][c.y][c.x];
      if(v!==EMPTY) drawPiece(c.x,c.y,z,v);
    }
  }

  // if gameover show overlay
  if(gameOver){
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font="900 46px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.textAlign="center";
    ctx.fillText(statusText.textContent, W/2, H/2);
    ctx.restore();
  }
}

function drawColumn(x,y){
  const p=colToScreen(x,y);
  const topY = p.gy;
  const baseY = p.gy + (N-1)*geom.layerDrop + 140;

  // vertical pillar
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,.10)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(p.gx, topY);
  ctx.lineTo(p.gx, baseY);
  ctx.stroke();

  // top diamond (click target)
  ctx.fillStyle="rgba(255,255,255,.04)";
  ctx.strokeStyle="rgba(255,255,255,.12)";
  ctx.lineWidth=1.5;
  const r=40;
  ctx.beginPath();
  ctx.moveTo(p.gx, topY-r);
  ctx.lineTo(p.gx+r, topY);
  ctx.lineTo(p.gx, topY+r);
  ctx.lineTo(p.gx-r, topY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // show column fullness
  const z=dropZ(board,x,y);
  ctx.fillStyle = (z<0) ? "rgba(255,80,80,.45)" : "rgba(124,92,255,.25)";
  ctx.beginPath(); ctx.arc(p.gx, topY, 5, 0, Math.PI*2); ctx.fill();

  // label
  ctx.fillStyle="rgba(255,255,255,.28)";
  ctx.font="12px system-ui, -apple-system";
  ctx.textAlign="center";
  ctx.fillText(`${x+1},${y+1}`, p.gx, topY+62);
  ctx.restore();
}

function drawPiece(x,y,z,player){
  const p=colToScreen(x,y);
  const yy = p.gy + (N-1 - z)*geom.layerDrop + 110;
  const xx = p.gx;

  ctx.save();
  // shadow
  ctx.globalAlpha=0.35;
  ctx.fillStyle="#000";
  ctx.beginPath();
  ctx.ellipse(xx+8,yy+12,26,10,0,0,Math.PI*2);
  ctx.fill();

  // piece body
  ctx.globalAlpha=1;
  const grad=ctx.createRadialGradient(xx-10,yy-10,6, xx,yy,34);
  if(player===HUMAN){
    grad.addColorStop(0,"rgba(255,245,210,1)");
    grad.addColorStop(0.5,"rgba(255,209,102,1)");
    grad.addColorStop(1,"rgba(160,110,10,1)");
  }else{
    grad.addColorStop(0,"rgba(220,250,255,1)");
    grad.addColorStop(0.5,"rgba(102,217,239,1)");
    grad.addColorStop(1,"rgba(10,90,120,1)");
  }
  ctx.fillStyle=grad;
  ctx.strokeStyle="rgba(255,255,255,.16)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(xx,yy,28,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();

  // highlight
  ctx.globalAlpha=0.28;
  ctx.fillStyle="#fff";
  ctx.beginPath();
  ctx.arc(xx-10,yy-12,9,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
}

rebuildHit();
draw();
updateTurnPill();
setStatus("あなたの手番");

// click handling
cv.addEventListener('pointerdown', (ev)=>{
  if(gameOver) return;
  if(current!==HUMAN) return;

  const rect=cv.getBoundingClientRect();
  const px = (ev.clientX-rect.left) * (cv.width/rect.width);
  const py = (ev.clientY-rect.top) * (cv.height/rect.height);

  // find hit column
  for(const h of colHit){
    if(pointInPoly(px,py,h.poly)){
      const mv=playMove(board,h.x,h.y,HUMAN);
      if(!mv) return;
      history.push(mv);
      draw();

      const w=checkWinner(board);
      if(w===HUMAN){
        gameOver=true; setStatus("あなたの勝ち"); updateTurnPill(); return;
      }
      if(isFull(board)){
        gameOver=true; setStatus("引き分け"); updateTurnPill(); return;
      }
      current=AI;
      updateTurnPill();
      aiTurn();
      return;
    }
  }
});

// resize: keep hit areas consistent (fixed canvas size but responsive CSS)
window.addEventListener('resize', ()=>{ /* no-op; hit uses canvas coords */ });

</script>
</body>
</html>
