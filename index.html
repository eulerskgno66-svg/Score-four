<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>立体四目 4×4×4（回転3D）vs 最強AI</title>
<style>
  :root{
    --bg:#0b1020; --panel:#121a33; --text:#e8eeff; --muted:#94a3c7;
    --p1:#f5c542; --p2:#111111; --accent:#7c5cff;
  }
  body{ margin:0; background:linear-gradient(180deg,var(--bg),#070a14); color:var(--text);
        font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif; }
  .wrap{ max-width:1100px; margin:0 auto; padding:14px; display:grid; gap:12px; grid-template-columns: 1fr 330px;}
  @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }
  .card{ background:rgba(18,26,51,.86); border:1px solid rgba(124,92,255,.22); border-radius:14px; overflow:hidden; box-shadow:0 12px 30px rgba(0,0,0,.25); }
  .topbar{ padding:12px 14px; display:flex; align-items:center; justify-content:space-between; gap:10px;
           background:rgba(255,255,255,.03); border-bottom:1px solid rgba(255,255,255,.06); }
  .title{ font-weight:850; letter-spacing:.4px; }
  .sub{ color:var(--muted); font-size:12px; line-height:1.35; }
  .pill{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.05);
         border:1px solid rgba(255,255,255,.08); font-size:12px; color:var(--muted); white-space:nowrap;}
  .side{ padding:12px 14px; display:grid; gap:12px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select{
    background:#0f1730; color:var(--text);
    border:1px solid rgba(255,255,255,.14); border-radius:10px;
    padding:10px 12px; font-weight:700; cursor:pointer;
  }
  button:hover{ border-color: rgba(124,92,255,.6); }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .status{ padding:10px 12px; background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08); border-radius:12px; }
  .kvs{ display:grid; gap:6px; }
  .kv{ display:flex; justify-content:space-between; gap:10px; font-size:13px; }
  .kv b{ color:var(--text); }
  .hint{ font-size:12px; color:var(--muted); line-height:1.5; }
  .legend{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
  .p1{ background:var(--p1); box-shadow:0 0 0 2px rgba(245,197,66,.25); }
  .p2{ background:var(--p2); box-shadow:0 0 0 2px rgba(255,255,255,.18); }
  #view3d{ width:100%; height:720px; touch-action:none; } /* OrbitControlsのため */
  @media (max-width: 980px){ #view3d{ height:560px; } }
</style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div>
        <div class="title">立体四目 4×4×4（重力あり / 回転3D）</div>
        <div class="sub">棒（16本）をタップして落とす / 直線に4つで勝ち（3D斜め含む）<br>指ドラッグ：回転 / ピンチ：ズーム</div>
      </div>
      <div class="pill" id="turnPill">Turn: -</div>
    </div>
    <div id="view3d"></div>
    <div class="sub" style="padding:10px 14px;border-top:1px solid rgba(255,255,255,.06);">
      操作：棒の上をタップ → 駒が落ちる。勝敗後は「リセット」or「1手戻す」。
    </div>
  </div>

  <div class="card">
    <div class="topbar">
      <div class="title">設定</div>
      <div class="sub">AI：反復深化 + αβ枝刈り + 置換表（強め）</div>
    </div>
    <div class="side">
      <div class="legend">
        <span class="dot p1"></span><span class="pill">あなた（先手）</span>
        <span class="dot p2"></span><span class="pill">AI（後手）</span>
      </div>

      <div class="row">
        <button id="resetBtn">リセット</button>
        <button id="undoBtn">1手戻す</button>
      </div>

      <div class="row">
        <label class="pill">AI強さ</label>
        <select id="levelSel">
          <option value="4">強い（深さ4）</option>
          <option value="5">かなり強い（深さ5）</option>
          <option value="6" selected>最強寄り（深さ6）</option>
          <option value="7">超強い（深さ7 / 重め）</option>
        </select>
      </div>

      <div class="row">
        <label class="pill">AI思考</label>
        <select id="thinkSel">
          <option value="350" selected>速い</option>
          <option value="650">普通</option>
          <option value="1100">粘る</option>
        </select>
      </div>

      <div class="status">
        <div class="kvs">
          <div class="kv"><span>状態</span><b id="statusText">準備OK</b></div>
          <div class="kv"><span>AI探索ノード</span><b id="nodeText">0</b></div>
          <div class="kv"><span>AI最終深さ</span><b id="depthText">-</b></div>
          <div class="kv"><span>AI候補</span><b id="pvText">-</b></div>
        </div>
      </div>

      <div class="hint">
        ・見やすさ重視で「木の台＋太い棒＋球」表示。<br/>
        ・指ドラッグで自由回転。タップ判定は「動かさずタップ」だと置ける。<br/>
        ・回転したいときはそのままドラッグ。置きたいときは軽くタップ。<br/>
      </div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ===============================
   ゲームロジック（AI含む）
   =============================== */
const N=4;
const EMPTY=0, HUMAN=1, AI=2;

function makeBoard(){
  const b=[];
  for(let z=0; z<N; z++){
    const layer=[];
    for(let y=0; y<N; y++) layer.push(new Array(N).fill(0));
    b.push(layer);
  }
  return b;
}

let board = makeBoard();
let history = []; // {x,y,z,player}
let gameOver=false;
let current = HUMAN;

// UI
const turnPill=document.getElementById('turnPill');
const statusText=document.getElementById('statusText');
const nodeText=document.getElementById('nodeText');
const depthText=document.getElementById('depthText');
const pvText=document.getElementById('pvText');
const resetBtn=document.getElementById('resetBtn');
const undoBtn=document.getElementById('undoBtn');
const levelSel=document.getElementById('levelSel');
const thinkSel=document.getElementById('thinkSel');

resetBtn.onclick=()=>resetGame();
undoBtn.onclick=()=>undoMove();

function setStatus(t){ statusText.textContent=t; }
function updateTurnPill(){
  if(gameOver){ turnPill.textContent="Game Over"; return; }
  turnPill.textContent = "Turn: " + (current===HUMAN?"あなた":"AI");
}

function disableInput(v){
  resetBtn.disabled=v;
  undoBtn.disabled=v;
  levelSel.disabled=v;
  thinkSel.disabled=v;
  inputLocked = v;
}

function resetGame(){
  board=makeBoard();
  history=[];
  gameOver=false;
  current=HUMAN;
  setStatus("あなたの手番");
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";
  rebuildPieces();
  updateTurnPill();
}

function undoMove(){
  if(history.length===0) return;
  if(gameOver){ gameOver=false; }

  const m1=history.pop();
  board[m1.z][m1.y][m1.x]=EMPTY;
  current=m1.player;

  if(current===AI && history.length>0){
    const m2=history.pop();
    board[m2.z][m2.y][m2.x]=EMPTY;
    current=m2.player;
  }
  setStatus("1手戻しました");
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";
  rebuildPieces();
  updateTurnPill();
}

function dropZ(b,x,y){
  for(let z=0; z<N; z++){
    if(b[z][y][x]===EMPTY) return z;
  }
  return -1;
}
function playMove(b,x,y,player){
  const z=dropZ(b,x,y);
  if(z<0) return null;
  b[z][y][x]=player;
  return {x,y,z,player};
}
function undoOnBoard(b,move){
  b[move.z][move.y][move.x]=EMPTY;
}

function inBounds(x,y,z){ return x>=0&&x<N&&y>=0&&y<N&&z>=0&&z<N; }

// all 3D direction vectors (unique up to sign)
const DIRS = [];
(function(){
  const seen=new Set();
  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      for(let dz=-1; dz<=1; dz++){
        if(dx===0&&dy===0&&dz===0) continue;
        let ndx=dx, ndy=dy, ndz=dz;
        if(ndx!==0){ if(ndx<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        else if(ndy!==0){ if(ndy<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        else { if(ndz<0){ ndx=-ndx; ndy=-ndy; ndz=-ndz; } }
        const key=`${ndx},${ndy},${ndz}`;
        if(!seen.has(key)){ seen.add(key); DIRS.push([ndx,ndy,ndz]); }
      }
    }
  }
})();

// precompute all 4-in-a-row lines as arrays of 4 cells
const LINES = [];
(function(){
  for(let x=0;x<N;x++)for(let y=0;y<N;y++)for(let z=0;z<N;z++){
    for(const [dx,dy,dz] of DIRS){
      const cells=[];
      for(let k=0;k<4;k++){
        const xx=x+dx*k, yy=y+dy*k, zz=z+dz*k;
        if(!inBounds(xx,yy,zz)){ cells.length=0; break; }
        cells.push([xx,yy,zz]);
      }
      if(cells.length===4){
        const px=x-dx, py=y-dy, pz=z-dz;
        if(!inBounds(px,py,pz)) LINES.push(cells);
      }
    }
  }
})();

function checkWinner(b){
  for(const line of LINES){
    const a=b[line[0][2]][line[0][1]][line[0][0]];
    if(a===EMPTY) continue;
    let ok=true;
    for(let i=1;i<4;i++){
      const [x,y,z]=line[i];
      if(b[z][y][x]!==a){ ok=false; break; }
    }
    if(ok) return a;
  }
  return 0;
}
function isFull(b){
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(dropZ(b,x,y)>=0) return false;
  }
  return true;
}
function legalMoves(b){
  const moves=[];
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(dropZ(b,x,y)>=0) moves.push({x,y});
  }
  return moves;
}

/* --- AI (negamax + alpha-beta + iterative deepening + TT) --- */

// Zobrist hashing
const Z = (function(){
  const arr=[null,[],[]];
  let seed=0x9e3779b9;
  function rnd32(){
    seed ^= (seed<<13)>>>0;
    seed ^= (seed>>>17)>>>0;
    seed ^= (seed<<5)>>>0;
    return seed>>>0;
  }
  for(let p=1;p<=2;p++){
    arr[p]=[];
    for(let z=0;z<N;z++){
      arr[p][z]=[];
      for(let y=0;y<N;y++){
        arr[p][z][y]=[];
        for(let x=0;x<N;x++){
          const hi=rnd32(), lo=rnd32();
          arr[p][z][y][x]=BigInt(hi)<<32n | BigInt(lo);
        }
      }
    }
  }
  const turnKey = BigInt(rnd32())<<32n | BigInt(rnd32());
  return {arr, turnKey};
})();

function hashBoard(b, turnPlayer){
  let h=0n;
  for(let z=0;z<N;z++)for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    const v=b[z][y][x];
    if(v!==EMPTY) h ^= Z.arr[v][z][y][x];
  }
  if(turnPlayer===AI) h ^= Z.turnKey;
  return h;
}

function evalBoard(b){
  const w=checkWinner(b);
  if(w===AI) return 1000000;
  if(w===HUMAN) return -1000000;
  let score=0;

  // center preference
  for(let z=0;z<N;z++)for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    const v=b[z][y][x];
    if(v===EMPTY) continue;
    const cx = 1.5 - Math.abs(1.5-x);
    const cy = 1.5 - Math.abs(1.5-y);
    const cz = 1.5 - Math.abs(1.5-z);
    const wgt = 1 + (cx+cy+cz)*0.20;
    score += (v===AI? +wgt : -wgt);
  }

  // line potentials
  for(const line of LINES){
    let a=0, h=0;
    for(const [x,y,z] of line){
      const v=b[z][y][x];
      if(v===AI) a++;
      else if(v===HUMAN) h++;
    }
    if(a>0 && h>0) continue;
    if(a===0 && h===0) continue;
    const W=[0, 12, 70, 550];
    if(a>0) score += W[a];
    else score -= W[h];
  }
  return Math.round(score);
}

const TT = new Map();
let aiNodes=0;
let stopAt=0;

function orderMoves(b, moves){
  const scored=[];
  for(const m of moves){
    let s=0;
    const cx = 1.5 - Math.abs(1.5-m.x);
    const cy = 1.5 - Math.abs(1.5-m.y);
    s += (cx+cy)*10;

    const mvA=playMove(b,m.x,m.y,AI);
    if(mvA){
      if(checkWinner(b)===AI) s += 100000;
      undoOnBoard(b,mvA);
    }
    const mvH=playMove(b,m.x,m.y,HUMAN);
    if(mvH){
      if(checkWinner(b)===HUMAN) s += 90000;
      undoOnBoard(b,mvH);
    }
    scored.push([s,m]);
  }
  scored.sort((a,b)=>b[0]-a[0]);
  return scored.map(x=>x[1]);
}

function negamax(b, depth, alpha, beta, turnPlayer){
  aiNodes++;
  if(performance.now()>stopAt) return {value: evalBoard(b), move:null, timeout:true};

  const h = hashBoard(b, turnPlayer);
  const tt = TT.get(h);
  if(tt && tt.depth>=depth){
    if(tt.flag===0) return {value: tt.value, move: tt.bestMove, timeout:false};
    if(tt.flag===1) alpha = Math.max(alpha, tt.value);
    else if(tt.flag===2) beta = Math.min(beta, tt.value);
    if(alpha>=beta) return {value: tt.value, move: tt.bestMove, timeout:false};
  }

  const w=checkWinner(b);
  if(w!==0) return {value: (w===AI? 1000000: -1000000) - (6-depth), move:null, timeout:false};
  if(depth===0 || isFull(b)) return {value: evalBoard(b), move:null, timeout:false};

  let bestMove=null;
  let bestVal=-Infinity;

  let moves=orderMoves(b, legalMoves(b));

  if(tt && tt.bestMove){
    const idx=moves.findIndex(m=>m.x===tt.bestMove.x && m.y===tt.bestMove.y);
    if(idx>0){
      const [m]=moves.splice(idx,1);
      moves.unshift(m);
    }
  }

  const alpha0 = alpha;
  for(const m of moves){
    const mv=playMove(b,m.x,m.y,turnPlayer);
    if(!mv) continue;

    const res = negamax(b, depth-1, -beta, -alpha, (turnPlayer===AI?HUMAN:AI));
    undoOnBoard(b,mv);

    if(res.timeout) return {value: bestVal, move: bestMove, timeout:true};

    const val = -res.value;
    if(val>bestVal){ bestVal=val; bestMove=m; }
    alpha=Math.max(alpha, bestVal);
    if(alpha>=beta) break;
  }

  // store TT with proper bound flag
  let flag=0; // exact
  if(bestVal<=alpha0) flag=2; // upper
  else if(bestVal>=beta) flag=1; // lower
  TT.set(h, {depth, flag, value:bestVal, bestMove});
  return {value: bestVal, move: bestMove, timeout:false};
}

async function aiTurn(){
  if(gameOver || current!==AI) return;

  const maxDepth = parseInt(levelSel.value,10);
  const thinkMs = parseInt(thinkSel.value,10);

  setStatus("AI思考中…");
  disableInput(true);

  aiNodes=0;
  nodeText.textContent="0";
  depthText.textContent="-";
  pvText.textContent="-";

  stopAt = performance.now() + thinkMs;

  let best=null;
  let bestVal=-Infinity;

  for(let d=1; d<=maxDepth; d++){
    const res = negamax(board, d, -Infinity, Infinity, AI);
    nodeText.textContent = String(aiNodes);
    if(res.timeout) break;
    if(res.move){
      best=res.move;
      bestVal=res.value;
      depthText.textContent=String(d);
      pvText.textContent=`(${best.x+1},${best.y+1}) val=${bestVal}`;
    }
    await new Promise(r=>setTimeout(r,0));
  }

  if(!best){
    const moves=legalMoves(board);
    best=moves[Math.floor(Math.random()*moves.length)];
  }

  const mv=playMove(board,best.x,best.y,AI);
  history.push(mv);

  rebuildPieces();

  const w=checkWinner(board);
  if(w===AI){ gameOver=true; setStatus("AIの勝ち"); updateTurnPill(); disableInput(false); return; }
  if(isFull(board)){ gameOver=true; setStatus("引き分け"); updateTurnPill(); disableInput(false); return; }

  current=HUMAN;
  setStatus("あなたの手番");
  updateTurnPill();
  disableInput(false);
}

/* ===============================
   3D表示（木の台＋太い棒＋球＋回転）
   =============================== */
const container = document.getElementById("view3d");
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1020);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 200);
camera.position.set(10, 11, 13);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.HemisphereLight(0xcfd8ff, 0x101018, 0.9));
const dir = new THREE.DirectionalLight(0xffffff, 1.25);
dir.position.set(9, 16, 7);
dir.castShadow = true;
dir.shadow.mapSize.set(1024, 1024);
scene.add(dir);

// Controls (回転)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 2.4, 0);
controls.minDistance = 10;
controls.maxDistance = 26;
controls.maxPolarAngle = Math.PI * 0.52;

// Materials
const wood = new THREE.MeshStandardMaterial({ color: 0xd7b98e, roughness: 0.65, metalness: 0.0 });
const pegMat = new THREE.MeshStandardMaterial({ color: 0xcaa77a, roughness: 0.55, metalness: 0.05 });
const p1Mat  = new THREE.MeshStandardMaterial({ color: 0xf5c542, roughness: 0.35, metalness: 0.05 });
const p2Mat  = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.45, metalness: 0.15 });

// Base
const base = new THREE.Mesh(new THREE.BoxGeometry(8.6, 0.6, 8.6), wood);
base.position.y = -0.3;
base.receiveShadow = true;
scene.add(base);

// Layout
const spacing = 2.0;
const start = -3.0;
const pegH = 7.4;
const pegR = 0.20;
const ballR = 0.58;
const layerStep = 1.45;
const y0 = 0.55;

// Pegs + tap targets
const pegMeshes = [];
const targetMeshes = [];
const pegGeo = new THREE.CylinderGeometry(pegR, pegR, pegH, 20);
const targetGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.25, 20); // クリックしやすい“上面”
const targetMat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 }); // 見えない

for (let y=0; y<4; y++){
  for (let x=0; x<4; x++){
    const peg = new THREE.Mesh(pegGeo, pegMat);
    peg.castShadow = true;
    peg.position.set(start + x*spacing, pegH/2 - 0.05, start + y*spacing);
    scene.add(peg);
    pegMeshes.push(peg);

    const tgt = new THREE.Mesh(targetGeo, targetMat);
    tgt.position.set(start + x*spacing, pegH + 0.20, start + y*spacing);
    tgt.userData = { colX:x, colY:y };
    scene.add(tgt);
    targetMeshes.push(tgt);
  }
}

// Pieces group
const piecesGroup = new THREE.Group();
scene.add(piecesGroup);

const sphereGeo = new THREE.SphereGeometry(ballR, 28, 28);

function rebuildPieces(){
  while(piecesGroup.children.length) piecesGroup.remove(piecesGroup.children[0]);

  for(let z=0; z<4; z++){
    for(let y=0; y<4; y++){
      for(let x=0; x<4; x++){
        const v = board[z][y][x];
        if(v===0) continue;

        const m = (v===1) ? p1Mat : p2Mat;
        const s = new THREE.Mesh(sphereGeo, m);
        s.castShadow = true;

        const yy = y0 + z*layerStep;
        s.position.set(start + x*spacing, yy, start + y*spacing);
        piecesGroup.add(s);
      }
    }
  }
}

// Tap vs Drag判定（回転と置く動作の両立）
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
let inputLocked = false;

let downX=0, downY=0, downT=0;
renderer.domElement.addEventListener("pointerdown", (ev)=>{
  downX = ev.clientX; downY = ev.clientY; downT = performance.now();
}, {passive:true});

renderer.domElement.addEventListener("pointerup", (ev)=>{
  if(inputLocked || gameOver || current!==HUMAN) return;

  const dx = Math.abs(ev.clientX - downX);
  const dy = Math.abs(ev.clientY - downY);
  const dt = performance.now() - downT;

  // 「ほぼ動かさず短時間」ならクリック扱い（回転ドラッグと区別）
  if(dx>10 || dy>10 || dt>450) return;

  const rect = renderer.domElement.getBoundingClientRect();
  const x = (ev.clientX - rect.left) / rect.width;
  const y = (ev.clientY - rect.top) / rect.height;
  pointer.x = x * 2 - 1;
  pointer.y = -(y * 2 - 1);

  raycaster.setFromCamera(pointer, camera);
  const hits = raycaster.intersectObjects(targetMeshes, false);
  if(!hits.length) return;

  const tgt = hits[0].object;
  const cx = tgt.userData.colX;
  const cy = tgt.userData.colY;

  const mv = playMove(board, cx, cy, HUMAN);
  if(!mv) return;

  history.push(mv);
  rebuildPieces();

  const w = checkWinner(board);
  if(w===HUMAN){ gameOver=true; setStatus("あなたの勝ち"); updateTurnPill(); return; }
  if(isFull(board)){ gameOver=true; setStatus("引き分け"); updateTurnPill(); return; }

  current = AI;
  updateTurnPill();
  aiTurn();
}, {passive:true});

// Resize
window.addEventListener("resize", ()=>{
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});

// Render loop
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

/* 初期化 */
setStatus("あなたの手番");
updateTurnPill();
rebuildPieces();
</script>
</body>
</html>

